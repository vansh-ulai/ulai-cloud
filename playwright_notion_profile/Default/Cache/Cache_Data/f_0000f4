"use strict";(globalThis.webpackChunknotion_next=globalThis.webpackChunknotion_next||[]).push([[87249],{24153:(e,t,n)=>{n.d(t,{A2:()=>f,NL:()=>y,YK:()=>k,ZI:()=>m,ph:()=>p,y1:()=>c});n(16280),n(814603),n(147566),n(198721);var r=()=>n(534177),i=()=>n(761865),o=()=>n(499919);const a="slackChannel",s="slackMessage",l="slackUser",c=[a,s,l];function d(e){return(0,o().$q)({id:e,prefix:l})}function u(e){return`${e.workspaceHost}/${e.userId}`}function p(e){return(0,r().zR)(e,l)}function g(e){return(0,o().$q)({id:e,prefix:s})}function h(e){return`${e.workspaceHost}/${e.channelId}/${v(e.messageTs)}/${v(e.threadTs)}`}function m(e){return(0,r().zR)(e,s)}const f={slackUser:{type:"slackUser",getUri:e=>{const t=U(e.workspaceHost),n=I({userId:e.userId,workspaceHost:t});if(n)return n;return d(u({userId:e.userId,workspaceHost:t}))},getUrl:e=>function(e){const{userId:t,workspaceHost:n}=e,r=I({userId:t,workspaceHost:n});return r||new URL(`/team/${t}`,`https://${n}`).toString()}(e),parseUri:e=>{if(w(e)){var t,n;const r=null===(t=(n=f.slackUser).parseUrlToUri)||void 0===t?void 0:t.call(n,e,{baseUrl:"",publicDomainName:""});return"string"==typeof r?f.slackUser.parseUri(r):new(i().Yv)("Invalid Slack user URI (URL): {uri}",{uri:e},{cause:r})}var r;const a=function(e){const t=e.split("/");if(2===t.length){const[e,n]=t;return I({userId:n,workspaceHost:e})||{userId:n,workspaceHost:e}}return new Error(`Invalid user ID: ${e}`)}((r=e,(0,o().AF)({prefix:l,id:r,originModule:"slack"})));return a instanceof Error?new(i().Yv)("Invalid Slack user URI: {uri}",{uri:e},{cause:a}):{type:"slackUser",userId:a.userId,workspaceHost:a.workspaceHost}},parseUrlToUri:e=>{if(p(e.toString()))return e.toString();const t=function(e,t){let n;try{n=new URL(e)}catch(l){return new Error(`Error in parseSlackUserUrlToUri: Invalid Slack user URL: ${e}. Expected format: https://workspace.slack.com/team/U0123456789`,{cause:l})}const{host:r,pathname:i}=n,o=i.match(/^\/team\/(?<userId>U[\w-]+)$/);if(null===o)return new Error(`Error in parseSlackUserUrlToUri: Invalid Slack user URL: ${e}. Expected format: https://workspace.slack.com/team/U0123456789`);const{userId:a}=o.groups??{},s=u({userId:a,workspaceHost:r});return t?d(s):s}(e.toString(),!0);return t instanceof Error?new(i().Yv)("Invalid Slack user URL: {url}",{url:e},{cause:t}):t}},slackMessage:{type:"slackMessage",getUri:e=>{const t=U(e.workspaceHost),n=I({channelId:e.channelId,messageTs:e.messageTs,threadTs:e.threadTs,workspaceHost:t});if(n)return n;return g(h({channelId:e.channelId,messageTs:e.messageTs,threadTs:e.threadTs,workspaceHost:t}))},getUrl:e=>function(e){const{workspaceHost:t,channelId:n,messageTs:r,threadTs:i}=e,o=I({channelId:n,messageTs:r,threadTs:i,workspaceHost:t});if(o)return o;const a=T(t),s=new URL(`/archives/${n}/p${l=r,l.replace(".","")}`,a);var l;return i&&i!==r&&(s.searchParams.set("cid",n),s.searchParams.set("thread_ts",v(i))),s.toString()}(e),parseUri:e=>{if(w(e)){var t,n;const r=null===(t=(n=f.slackMessage).parseUrlToUri)||void 0===t?void 0:t.call(n,e,{baseUrl:"",publicDomainName:""});return"string"==typeof r?f.slackMessage.parseUri(r):new(i().Yv)("Invalid Slack message URI (URL): {uri}",{uri:e},{cause:r})}var r;const a=function(e){const t=e.split("/");if(4===t.length){const[e,n]=t;let[,,r,i]=t;r=v(r),i=v(i);return I({channelId:n,messageTs:r,threadTs:i,workspaceHost:e})||{channelId:n,messageTs:r,threadTs:i,workspaceHost:e}}return new Error(`Invalid message ID: ${e}`)}((r=e,(0,o().AF)({id:r,originModule:"slack",prefix:s})));return a instanceof Error?new(i().Yv)("Invalid Slack message URI: {uri}",{uri:e},{cause:a}):{type:"slackMessage",channelId:a.channelId,messageTs:a.messageTs,threadTs:a.threadTs,workspaceHost:a.workspaceHost}},parseUrlToUri:e=>{if(m(e.toString()))return e.toString();const t=function(e,t){let n;try{n=new URL(e)}catch(u){return new Error(`Error in parseSlackMessageUrlToId: Invalid Slack message URL: ${e}. Expected format: https://workspace.slack.com/archives/C0123ABCDEF/p9876543210987654 or https://workspace.slack.com/archives/C0123ABCDEF/p9876543210987654?thread_ts=12345`,{cause:u})}const{host:r,pathname:i,searchParams:o}=n,a=i.match(/^\/archives\/(?<channelId>[\w-]+)\/p(?<messageTimestamp>[\d]+)$/);if(null===a)return new Error(`Error in parseSlackMessageUrlToId: Invalid Slack message URL: ${e}. Expected format: https://workspace.slack.com/archives/C0123ABCDEF/p9876543210987654 or https://workspace.slack.com/archives/C0123ABCDEF/p9876543210987654?thread_ts=12345`);const{channelId:s,messageTimestamp:l}=a.groups??{},c=o.get("thread_ts")??void 0,d=h({channelId:s,threadTs:c||l,messageTs:l,workspaceHost:r});return t?g(d):d}(e.toString(),!0);return t instanceof Error?new(i().Yv)("Invalid Slack message URL: {url}",{url:e},{cause:t}):t}},slackChannel:{type:"slackChannel",parseUri:e=>{if(w(e)){try{var t;const n=new URL(e),r=n.pathname.match(/^\/archives\/(?<channelId>[\w-]+)\/?$/),i=null==r||null===(t=r.groups)||void 0===t?void 0:t.channelId;if(i){return{type:"slackChannel",id:i,workspaceUrl:`${n.protocol}//${n.hostname}`}}}catch{}return new(i().Yv)(`Invalid Slack channel URL: ${e}`)}return{type:"slackChannel",id:(n=e,(0,o().AF)({prefix:a,id:n,originModule:"slack"}))};var n},getUri:e=>{if(e.id.startsWith("https://"))return e.id;if(e.workspaceUrl){return`${e.workspaceUrl.endsWith("/")?e.workspaceUrl.slice(0,-1):e.workspaceUrl}/archives/${e.id}`}return`slackChannel://${e.id}`},parseUrlToUri:e=>{var t;const n=new URL(e);if(!n.hostname.toLowerCase().endsWith("slack.com"))return new(i().Yv)("Invalid Slack channel URL: {url}",{url:n});const r=n.pathname.match(/^\/archives\/(?<channelId>[\w-]+)\/?$/);return(null==r||null===(t=r.groups)||void 0===t?void 0:t.channelId)?n.toString():new(i().Yv)("Invalid Slack channel URL: {url}",{url:n})}}};function y(e){return/^C[A-Z0-9]+$/.test(e)}function b(e){return/^[0-9]{10}\.[0-9]+$/.test(e)}function k(e){return"*"===e||"public:*"===e||"slackChannel://*"===e}function I(e){const{channelId:t,messageTs:n,threadTs:i,userId:o,workspaceHost:a}=e;if(a){if(!w((0,r().zR)(a,"https://")?a:`https://${a}`))return new Error(`Invalid workspace URL: ${a}`)}return!t||y(t)||function(e){return/^D[A-Z0-9]+$/.test(e)}(t)||function(e){return/^G[A-Z0-9]+$/.test(e)}(t)?n&&!b(n)?new Error(`Invalid message timestamp: ${n}`):i&&!b(i)?new Error(`Invalid thread timestamp: ${i}`):o&&!function(e){return/^U[\w]+$/.test(e)}(o)?new Error(`Invalid user ID: ${o}`):void 0:new Error(`Invalid channel ID: ${t}`)}function w(e){try{const t=new URL(e);return"https:"===t.protocol&&t.hostname.toLowerCase().endsWith("slack.com")}catch{return!1}}function v(e){return e.includes(".")||e.length<16?e:`${e.slice(0,10)}.${e.slice(10)}`}function T(e){let t=e;return(0,r().zR)(e,"https://")||(t=`https://${e}`),t}function U(e){const t=T(e);return new URL(t).host}},66757:(e,t,n)=>{n.d(t,{zP:()=>U,JN:()=>x});var r=()=>n(638681);const i={dataTypes:"",dataTypesArray:[],persistedStateValidator:r().object({required:{},optional:{},exact:!0}),persistedState:"",triggers:{},effects:{"calendar.runTool":"\n(args: {\n\t\t\t\ttoolArguments: Record<string, unknown>\n\t\t\t\ttoolName: string\n\t\t\t}) => Promise<CalendarToolCallResult>","calendar.fetchPlaybook":"\n(args: {\n\t\tname: string\n\t\targuments?: Record<string, string>\n\t}) => Promise<McpServerGetPromptToolResult>"},effectsArray:["calendar.runTool","calendar.fetchPlaybook"],effectsValidators:{"calendar.runTool":r().object({required:{toolArguments:r().record(r().string(),r().unknown()),toolName:r().string()},optional:{},exact:!0}),"calendar.fetchPlaybook":r().object({required:{name:r().string()},optional:{arguments:r().record(r().string(),r().string())},exact:!0})}};var o=()=>n(669604);r().literals("COMPLETE","ERROR","FAILED","PENDING","RUNNING"),r().object({required:{createdAt:r().string(),id:r().string(),status:r().string(),webUrl:r().string()},optional:{githubPullRequests:r().array(r().object({required:{createdAt:r().string(),id:r().string(),title:r().string(),url:r().string()},optional:{},exact:!0})),metadata:r().object({required:{},optional:{userEmail:r().string()},exact:!0}),polling:r().boolean(),pollingStatus:r().string(),result:r().string()},exact:!0}),r().object({required:{prompt:r().string()},optional:{images:r().array(r().string()),metadata:r().object({required:{},optional:{userEmail:r().string()},exact:!0}),runId:r().string()},exact:!0}),r().object({required:{runId:r().string()},optional:{poll:r().boolean()},exact:!0});const a={dataTypes:'\ntype CodegenRunStatus =\n\t| "PENDING"\n\t| "RUNNING"\n\t| "COMPLETE"\n\t| "ERROR"\n\t| "FAILED"\n\ninterface CodegenRunResult {\n\tid: string\n\tstatus: string\n\tcreatedAt: string\n\twebUrl: string\n\tresult?: string\n\tpolling?: boolean\n\tpollingStatus?: string\n\tgithubPullRequests?: {\n\t\tid: string\n\t\ttitle: string\n\t\turl: string\n\t\tcreatedAt: string\n\t}[]\n\tmetadata?: {\n\t\tuserEmail?: string\n\t}\n}\n\ntype CodegenRunInput = {\n\tprompt: string\n\timages?: Array<string> // Optional base64 encoded images\n\trunId?: string // Optional run ID to resume an existing run instead of creating a new one\n\tmetadata?: {\n\t\tuserEmail?: string\n\t}\n}\n\ntype CodegenRunStatusInput = {\n\trunId: string\n\tpoll?: boolean // Optional boolean to indicate whether to poll for results every minute until completion\n}',dataTypesArray:["CodegenRunStatus","CodegenRunResult","CodegenRunInput","CodegenRunStatusInput"],persistedStateValidator:r().object({required:{},optional:{connectionPointer:(0,o().VR)("workflow_external_connection")},exact:!0}),persistedState:"connectionPointer?: RecordPointer<WorkflowExternalConnectionTable>",triggers:{},effects:{"codegen.run":"run(args: CodegenRunInput): Promise<CodegenRunResult>","codegen.runStatus":"runStatus(args: CodegenRunStatusInput): Promise<CodegenRunResult>"},effectsArray:["codegen.run","codegen.runStatus"],effectsValidators:{"codegen.run":r().object({required:{prompt:r().string()},optional:{images:r().array(r().string()),metadata:r().object({required:{},optional:{userEmail:r().string()},exact:!0}),runId:r().string()},exact:!0}),"codegen.runStatus":r().object({required:{runId:r().string()},optional:{poll:r().boolean()},exact:!0})}},s=r().object({required:{},optional:{},exact:!0}),l=(r().string(),{dataTypes:"",dataTypesArray:[],persistedStateValidator:s,persistedState:"",triggers:{},effects:{},effectsArray:[],effectsValidators:{}}),c=(r().object({required:{id:r().string()},optional:{},exact:!0}),{dataTypes:"\ntype File = {\n\tid: string\n}",dataTypesArray:["File"],persistedStateValidator:r().object({required:{},optional:{},exact:!0}),persistedState:"",triggers:{},effects:{"files.getFileContent":"getFileContent(args: { fileId: string }): Promise<string | undefined>","files.getFileUrl":"getFileUrl(args: { fileId: string }): Promise<string | undefined>","files.getFileName":"getFileName(args: { fileId: string }): Promise<string | undefined>"},effectsArray:["files.getFileContent","files.getFileUrl","files.getFileName"],effectsValidators:{"files.getFileContent":r().object({required:{fileId:r().string()},optional:{},exact:!0}),"files.getFileUrl":r().object({required:{fileId:r().string()},optional:{},exact:!0}),"files.getFileName":r().object({required:{fileId:r().string()},optional:{},exact:!0})}});const d={dataTypes:"",dataTypesArray:[],persistedStateValidator:r().object({required:{},optional:{},exact:!0}),persistedState:"",triggers:{},effects:{"mail.runTool":"\n(args: {\n\t\ttoolArguments: Record<string, unknown>\n\t\ttoolName: string\n\t}) => Promise<McpServerToolCallResult>","mail.getPrompt":"\n(args: {\n\t\tname: string\n\t\targuments?: Record<string, string>\n\t}) => Promise<McpServerGetPromptToolResult>"},effectsArray:["mail.runTool","mail.getPrompt"],effectsValidators:{"mail.runTool":r().object({required:{toolArguments:r().record(r().string(),r().unknown()),toolName:r().string()},optional:{},exact:!0}),"mail.getPrompt":r().object({required:{name:r().string()},optional:{arguments:r().record(r().string(),r().string())},exact:!0})}},u={dataTypes:"",dataTypesArray:[],persistedStateValidator:r().object({required:{},optional:{connectionPointer:(0,o().IK)("workflow_external_scoped_connection"),serverUrl:r().string()},exact:!0}),persistedState:"\nserverUrl?: string\nconnectionPointer?: RecordPointer<WorkflowExternalScopedConnectionTable>",triggers:{},effects:{"mcpServer.runTool":"\n(args: {\n\t\ttoolArguments: Record<string, unknown>\n\t\ttoolName: string\n\t}) => Promise<McpServerToolCallResult>","mcpServer.listResources":"\n(args: {\n\t\tcursor?: string\n\t}) => Promise<McpServerListResourcesToolResult>","mcpServer.readResource":"\n(args: {\n\t\turi: string\n\t}) => Promise<McpServerReadResourceToolResult>","mcpServer.listPrompts":"\n(args: {\n\t\tcursor?: string\n\t}) => Promise<McpServerListPromptsToolResult>","mcpServer.getPrompt":"\n(args: {\n\t\tname: string\n\t\targuments?: Record<string, string>\n\t}) => Promise<McpServerGetPromptToolResult>"},effectsArray:["mcpServer.runTool","mcpServer.listResources","mcpServer.readResource","mcpServer.listPrompts","mcpServer.getPrompt"],effectsValidators:{"mcpServer.runTool":r().object({required:{toolArguments:r().record(r().string(),r().unknown()),toolName:r().string()},optional:{},exact:!0}),"mcpServer.listResources":r().object({required:{},optional:{cursor:r().string()},exact:!0}),"mcpServer.readResource":r().object({required:{uri:r().string()},optional:{},exact:!0}),"mcpServer.listPrompts":r().object({required:{},optional:{cursor:r().string()},exact:!0}),"mcpServer.getPrompt":r().object({required:{name:r().string()},optional:{arguments:r().record(r().string(),r().string())},exact:!0})}},p=r().literals("comment_only","read_and_write","reader"),g=(r().union([r().object({required:{actions:r().array(r().lazy((()=>p))),identifier:r().union([r().object({required:{blockId:r().uuid(),type:r().literal("pageOrCollectionViewBlock")},optional:{},exact:!0}),r().object({required:{type:r().literal("workspacePublic")},optional:{},exact:!0})]),type:r().literal("notion")},optional:{},exact:!0}),r().object({required:{actions:r().array(r().literals("allow","disallow")),identifier:r().union([r().object({required:{type:r().literal("helpdocs")},optional:{},exact:!0}),r().object({required:{type:r().literal("web")},optional:{},exact:!0})]),type:r().literal("search")},optional:{},exact:!0})]),r().union([r().object({required:{actions:r().array(r().literals("allow","disallow")),identifier:r().literal("helpdocsSearch")},optional:{},exact:!0}),r().object({required:{actions:r().array(r().literals("allow","disallow")),identifier:r().literal("webSearch")},optional:{},exact:!0}),r().object({required:{actions:r().array(r().literals("comment","edit","view")),identifier:r().union([r().array(r().string()),r().string()])},optional:{},exact:!0})]),r().object({required:{interval:r().number(),timezone:r().string(),type:r().literal("recurrence")},optional:{hour:r().number(),minute:r().number(),scheduleId:r().string()},exact:!0}),r().union([r().object({required:{frequency:r().literal("day")},optional:{},exact:!0}),r().object({required:{frequency:r().literal("month")},optional:{monthly_restriction:r().union([r().object({required:{monthdays:r().array(r().number()),type:r().literal("monthdays")},optional:{},exact:!0}),r().object({required:{type:r().literal("weekdays_in_month"),week_numbers:r().array(r().number()),weekdays:r().array(r().literals("FR","MO","SA","SU","TH","TU","WE"))},optional:{},exact:!0})])},exact:!0}),r().object({required:{frequency:r().literal("week")},optional:{weekdays:r().array(r().literals("FR","MO","SA","SU","TH","TU","WE"))},exact:!0}),r().object({required:{frequency:r().literal("year")},optional:{},exact:!0})]),{dataTypes:'\ntype RecurrenceTriggerBase = {\n\ttype: "recurrence"\n\tinterval: number // e.g. every 2 days, every 2 weeks\n\ttimezone: string // e.g. "America/New_York". Default to the user\'s current timezone unless otherwise specified.\n\thour?: number // Optional, 0-23\n\tminute?: number /\n\ntype RecurrenceTriggerFrequencyConfig =\n\t| {\n\t\t\tfrequency: "day"\n\t  }\n\t| {\n\t\t\tfrequency: "week"\n\t\t\tweekdays?: Array<"MO" | "TU" | "WE" | "TH" | "FR" | "SA" | "SU"> // Optional, trigger only on certain weekdays\n\t  }\n\t| {\n\t\t\tfrequency: "month"\n\t\t\tmonthly_restriction?:\n\t\t\t\t| {\n\t\t\t\t\t\ttype: "monthdays"\n\t\t\t\t\t\tmonthdays: Array<number>\n\t\t\t\t  }\n\t\t\t\t| {\n\t\t\t\t\t\ttype: "weekdays_in_month"\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * Only execute on these weekdays.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tweekdays: Array<"MO" | "TU" | "WE" | "TH" | "FR" | "SA" | "SU">\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * On these week numbers. Note that "-1" means the last week\n\t\t\t\t\t\t * of the month.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tweek_numbers: Array<number>\n\t\t\t\t  }\n\t  }\n\t| {\n\t\t\tfrequency: "year"\n\t  }',dataTypesArray:["RecurrenceTriggerBase","RecurrenceTriggerFrequencyConfig"],persistedStateValidator:r().object({required:{},optional:{ownedByDatabasePropertyIds:r().array(r().string())},exact:!0}),persistedState:"ownedByDatabasePropertyIds?: Array<string>",triggers:{recurrence:{state:"\nexport type RecurrenceTrigger = RecurrenceTriggerBase &\n\tRecurrenceTriggerFrequencyConfig",stateValidator:r().union([r().object({required:{frequency:r().literal("day"),interval:r().number(),timezone:r().string(),type:r().literal("recurrence")},optional:{hour:r().number(),minute:r().number(),scheduleId:r().string()},exact:!0}),r().object({required:{frequency:r().literal("month"),interval:r().number(),timezone:r().string(),type:r().literal("recurrence")},optional:{hour:r().number(),minute:r().number(),monthly_restriction:r().union([r().object({required:{monthdays:r().array(r().number()),type:r().literal("monthdays")},optional:{},exact:!0}),r().object({required:{type:r().literal("weekdays_in_month"),week_numbers:r().array(r().number()),weekdays:r().array(r().literals("FR","MO","SA","SU","TH","TU","WE"))},optional:{},exact:!0})]),scheduleId:r().string()},exact:!0}),r().object({required:{frequency:r().literal("week"),interval:r().number(),timezone:r().string(),type:r().literal("recurrence")},optional:{hour:r().number(),minute:r().number(),scheduleId:r().string(),weekdays:r().array(r().literals("FR","MO","SA","SU","TH","TU","WE"))},exact:!0}),r().object({required:{frequency:r().literal("year"),interval:r().number(),timezone:r().string(),type:r().literal("recurrence")},optional:{hour:r().number(),minute:r().number(),scheduleId:r().string()},exact:!0})])},"notion.page.discussion.comment.added":{state:'\ntype: "notion.page.discussion.comment.added"\ncollectionId?: string // UUID of the collection/database',stateValidator:r().object({required:{type:r().literal("notion.page.discussion.comment.added")},optional:{collectionId:r().string()},exact:!0})},"notion.page.created":{state:'\ntype: "notion.page.created"\ncollectionId?: string // UUID of the collection/database',stateValidator:r().object({required:{type:r().literal("notion.page.created")},optional:{collectionId:r().string()},exact:!0})},"notion.page.updated":{state:'\ntype: "notion.page.updated"\ncollectionId?: string // UUID of the collection/database\npropertyIds?: string[] // Optional array of property URLs or names to watch\nshouldIgnorePageContentUpdates?: boolean',stateValidator:r().object({required:{type:r().literal("notion.page.updated")},optional:{collectionId:r().string(),propertyIds:r().array(r().string()),shouldIgnorePageContentUpdates:r().boolean()},exact:!0})},"notion.page.deleted":{state:'\ntype: "notion.page.deleted"\ncollectionId?: string // UUID of the collection/database',stateValidator:r().object({required:{type:r().literal("notion.page.deleted")},optional:{collectionId:r().string()},exact:!0})},"notion.database.agent.updated":{state:'\ntype: "notion.database.agent.updated"\ncollectionId?: RecordId<CollectionTable>',stateValidator:r().object({required:{type:r().literal("notion.database.agent.updated")},optional:{collectionId:r().uuid()},exact:!0})},"notion.button.pressed":{state:'type: "notion.button.pressed"',stateValidator:r().object({required:{type:r().literal("notion.button.pressed")},optional:{},exact:!0})},"notion.agent.mentioned":{state:'type: "notion.agent.mentioned"',stateValidator:r().object({required:{type:r().literal("notion.agent.mentioned")},optional:{},exact:!0})}},effects:{"notion.sendNotification":"\n/*\n\t\tSend a notification to a user within Notion using the in-app Notion notification system\n\t*/\n\tsendNotification(args: {\n\t\tbodyContent: string\n\t\theaderContent: string\n\t\tuserIds: Array<string>\n\t\tsendToWorkflowOwner: boolean\n\t}): Promise<NotificationMessage>","notion.getPageDiscussions":"\n/*\n\t\tGets all discussions for a page. Pages can have multiple discussions, some of which may be resolved.\n\t*/\n\tgetPageDiscussions(args: {\n\t\tpageId: string // The id of the page to get discussions for.\n\t\tincludeResolved?: boolean // Whether to include resolved discussions.\n\t}): Promise<Array<NotionDiscussion>>","notion.addCommentToPage":"\n/*\n\t\tAdds a comment to a page, creating a new discussion if one does not exist.\n\t*/\n\taddCommentToPage(args: {\n\t\tpageId: string // The id of the page to add a comment to.\n\t\ttext: string // Inline-only markdown text. Only supports inline elements (bold, italics, code) but not blocks (headers, lists).\n\t\tattachedFileIds?: Array<string> // The file IDs of any files to attach to the comment.\n\t}): Promise<NotionComment>","notion.addCommentToDiscussion":"\n/*\n\t\tAdds a comment to an existing discussion.\n\t*/\n\taddCommentToDiscussion(args: {\n\t\tdiscussionId: string // The id of the discussion to add a comment to.\n\t\ttext: string // Inline-only markdown text. Only supports inline elements (bold, italics, code) but not blocks (headers, lists).\n\t\tattachedFileIds?: Array<string> // The file IDs of any files to attach to the comment.\n\t}): Promise<NotionComment>"},effectsArray:["notion.sendNotification","notion.getPageDiscussions","notion.addCommentToPage","notion.addCommentToDiscussion"],effectsValidators:{"notion.sendNotification":r().object({required:{bodyContent:r().string(),headerContent:r().string(),sendToWorkflowOwner:r().boolean(),userIds:r().array(r().string())},optional:{},exact:!0}),"notion.getPageDiscussions":r().object({required:{pageId:r().string()},optional:{includeResolved:r().boolean()},exact:!0}),"notion.addCommentToPage":r().object({required:{pageId:r().string(),text:r().string()},optional:{attachedFileIds:r().array(r().string())},exact:!0}),"notion.addCommentToDiscussion":r().object({required:{discussionId:r().string(),text:r().string()},optional:{attachedFileIds:r().array(r().string())},exact:!0})}}),h={dataTypes:"",dataTypesArray:[],persistedStateValidator:r().object({required:{},optional:{actions:r().array(r().object({required:{description:r().string(),id:r().string(),name:r().string(),parameters:r().record(r().string(),r().unknown())},optional:{},exact:!0})),connectionPointer:(0,o().IK)("workflow_external_scoped_connection"),integration:r().string(),triggers:r().array(r().object({required:{description:r().string(),id:r().string(),name:r().string(),parameters:r().record(r().string(),r().unknown())},optional:{},exact:!0}))},exact:!0}),persistedState:'\n/** Upstream service the user selected for this module (e.g. "github", "stripe"). */\n// Move integration and accountId to connectionPointer?\nintegration?: string\nconnectionPointer?: RecordPointer<WorkflowExternalScopedConnectionTable>\ntriggers?: Array<{\n\tid: string\n\tname: string\n\tdescription: string\n\tparameters: Record<string, unknown>\n}>\nactions?: Array<{\n\tid: string\n\tname: string\n\tdescription: string\n\tparameters: Record<string, unknown>\n}>',triggers:{"pipedream.trigger":{state:'readonly type: "pipedream.trigger"',stateValidator:r().object({required:{type:r().literal("pipedream.trigger")},optional:{},exact:!0})}},effects:{"pipedream.action":"\naction(args: {\n\t\ttoolName: string\n\t\ttoolArguments: Record<string, unknown>\n\t}): Promise<unknown>"},effectsArray:["pipedream.action"],effectsValidators:{"pipedream.action":r().object({required:{toolArguments:r().record(r().string(),r().unknown()),toolName:r().string()},optional:{},exact:!0})}},m=(r().object({required:{actions:r().array(r().literals("react","read","replyInThread","write")),identifier:r().union([r().array(r().string()),r().string()]),type:r().literal("slack")},optional:{},exact:!0}),r().object({required:{actions:r().array(r().literals("react","read","replyInThread","write")),identifier:r().union([r().array(r().string()),r().string()])},optional:{},exact:!0}),r().object({required:{},optional:{connectionPointer:(0,o().IK)("workflow_external_scoped_connection"),name:r().string(),scopes:r().array(r().string())},exact:!0})),f={"slack.reaction.added":{state:'\ntype: "slack.reaction.added"\nchannelIds?: Array<string> // IDs of channels to trigger on. If you do not know the channel ID, you can leave this blank and the user will fill it out later. DO NOT make up channel IDs.\nchannelIdentifiersToConvertToChannelIds?: Array<string> // Channels to trigger on. NOT channel IDs, but anything else. We will try to convert these to channel IDs. Only include here if you KNOW it\'s not a channel ID\nallChannels?: boolean // Whether to trigger on all channels. Set to false. Only set this to true if the user explicitly mentions triggering from all channels. The bot must be a member of a channel to trigger from it.\nreactions?: string[] // Optionally, trigger on specific reactions. If provided, only these reaction will cause the function to trigger. If not provided, any reaction will cause the function to trigger. An array of plain string without colons, like "thumbsup".\nshouldSubscribeToThread?: boolean // Whether to subscribe to the thread after the reaction is added. If true, the function will trigger when new messages are posted in the thread.\n/**\n * @deprecated\n * We can no longer add properties that change per trigger to this type, it causes issues with\n * published versions of the workflow (for one). We currently use WorkflowArtifact table for things like this\n */\nfrom?: SlackFrom // The user or bot that originally reacted to the message.',stateValidator:r().object({required:{type:r().literal("slack.reaction.added")},optional:{allChannels:r().boolean(),channelIdentifiersToConvertToChannelIds:r().array(r().string()),channelIds:r().array(r().string()),from:r().union([r().object({required:{handle:r().string(),id:r().string(),type:r().literal("user"),uri:r().string()},optional:{},exact:!0}),r().object({required:{type:r().literal("bot")},optional:{},exact:!0})]),reaction:r().string(),reactions:r().array(r().string()),shouldSubscribeToThread:r().boolean(),threadIds:r().array(r().string())},exact:!0})},"slack.message":{state:'\ntype: "slack.message"\nchannelIds?: Array<string> // IDs of channels to trigger on. If you do not know the channel ID, you can leave this blank and the user will fill it out later. DO NOT make up channel IDs.\nchannelIdentifiersToConvertToChannelIds?: Array<string> // Channels to trigger on. NOT channel IDs, but anything else. We will try to convert these to channel IDs. Only include here if you KNOW it\'s not a channel ID',stateValidator:r().object({required:{type:r().literal("slack.message")},optional:{allChannels:r().boolean(),channelIdentifiersToConvertToChannelIds:r().array(r().string()),channelIds:r().array(r().string())},exact:!0})},"slack.thread.created":{state:'\ntype: "slack.thread.created"\nchannelIds?: Array<string> // IDs of channels to trigger on. If you do not know the channel ID, you can leave this blank and the user will fill it out later. DO NOT make up channel IDs.\nchannelIdentifiersToConvertToChannelIds?: Array<string> // Channels to trigger on. NOT channel IDs, but anything else. We will try to convert these to channel IDs. Only include here if you KNOW it\'s not a channel ID',stateValidator:r().object({required:{type:r().literal("slack.thread.created")},optional:{allChannels:r().boolean(),channelIdentifiersToConvertToChannelIds:r().array(r().string()),channelIds:r().array(r().string())},exact:!0})},"slack.app.mention":{state:'\ntype: "slack.app.mention"\nchannelIds?: Array<string>\nchannelIdentifiersToConvertToChannelIds?: Array<string> //Channels to trigger on. NOT channel IDs, but anything else. We will try to convert these to channel IDs. Only include here if you KNOW it\'s not a channel ID\nallChannels?: boolean',stateValidator:r().object({required:{type:r().literal("slack.app.mention")},optional:{allChannels:r().boolean(),channelIdentifiersToConvertToChannelIds:r().array(r().string()),channelIds:r().array(r().string())},exact:!0})}},y={"slack.createThreadInChannel":'\n/*\n\t\tSlack channels must be a plain string, ie. "engineering".\n\t\tAll messages use standard markdown that also accepts slack markdown users and channels. For example:\n\t\tlink: [google](https://google.com)\n\t\tbold: **bold** or __bold__\n\t\titalics: *italics* or _italics_\n\t\tslack user: <@UFAKEUSERID>\n\t\tslack channel: <#CFAKECHANNEL>\n\t\tFormatting MUST not span multiple lines. It is important that bold is TWO asterisks, not one.\n\t*/\n\tcreateThreadInChannel(\n\t\targs:\n\t\t\t| {\n\t\t\t\t\tattachedFileIds?: Array<string> // The file IDs of any files attached to the message\n\t\t\t\t\tchannelName: string // Slack channel name without a "#" prefix.\n\t\t\t\t\tmessage: string // Standard markdown with slack markdown support\n\t\t\t  }\n\t\t\t| {\n\t\t\t\t\tattachedFileIds?: Array<string> // The file IDs of any files attached to the message\n\t\t\t\t\tchannelId: string // The Slack ID of the channel or user ID to send the message in.\n\t\t\t\t\tmessage: string // Standard markdown with slack markdown support\n\t\t\t  },\n\t): Promise<SlackMessage>',"slack.createThreadInDirectMessage":'\ncreateThreadInDirectMessage(args: {\n\t\tuserIds: Array<string> // Array of user IDs for the direct message recipients, beginning with "slackUser-"\n\t\tmessage: string // Standard markdown with slack markdown support\n\t\tattachedFileIds?: Array<string> // The file IDs of any files attached to the message\n\t}): Promise<SlackMessage>',"slack.replyInThread":"\nreplyInThread(args: {\n\t\tprefixedThreadUri: string // The thread ID is always the same as the message ID of the first message in a thread.\n\t\tmessage: string // Standard markdown with slack markdown support\n\t\tattachedFileIds?: Array<string> // The file IDs of any files attached to the message\n\t}): Promise<SlackMessage>","slack.updateMessage":"\nupdateMessage(args: {\n\t\tprefixedMessageUri: string\n\t\tmessage: string // Standard markdown with slack markdown support\n\t}): Promise<SlackMessage>","slack.addReactionToMessage":'\naddReactionToMessage(args: {\n\t\tprefixedMessageUri: string\n\t\treaction: string // Plain string without colons, like "thumbsup".\n\t}): Promise<void>',"slack.removeReactionFromMessage":'\nremoveReactionFromMessage(args: {\n\t\tprefixedMessageUri: string\n\t\treaction: string // Plain string without colons, like "thumbsup".\n\t}): Promise<void>',"slack.getThreadsInChannelSince":'\ngetThreadsInChannelSince(args: {\n\t\tchannelName: string // Slack channel name without a "#" prefix.\n\t\ttimestamp: string // ISO 8601 timestamp\n\t}): Promise<Array<Array<SlackMessage>>> // Returns an array of threads, where each thread is an array of messages.',"slack.queryChannels":"\nqueryChannels(args: {\n\t\tid?: string\n\t\tname?: string\n\t\tcreatedStart?: string // ISO 8601 timestamp. Returns channels created on or after this timestamp.\n\t\tcreatedEnd?: string // ISO 8601 timestamp. Returns channels created on or before this timestamp.\n\t\tisGeneral?: boolean\n\t\tisIm?: boolean\n\t\tisPrivate?: boolean\n\t\tisMpim?: boolean\n\t\tisShared?: boolean\n\t\tisOrgShared?: boolean\n\t\tbotIsMember?: boolean\n\t}): Promise<Array<SlackChannel>>","slack.getUser":"getUser(args: { userId: string }): Promise<SlackUser>","slack.findUserByEmail":"\n/*\n\t\tFind a Slack user by email.\n\t*/\n\tfindUserByEmail(args: { email: string }): Promise<SlackUser | undefined>","slack.parseSlackMessageUrlToId":"\n// TODO: Remove these in favor of general ID -> URL and URL -> ID helpers.\n\t// Maybe with a version that asserts a URI schema.\n\tparseSlackMessageUrlToId(args: { url: string }): string"},b={"slack.createThreadInChannel":r().union([r().object({required:{channelId:r().string(),message:r().string()},optional:{attachedFileIds:r().array(r().string())},exact:!0}),r().object({required:{channelName:r().string(),message:r().string()},optional:{attachedFileIds:r().array(r().string())},exact:!0})]),"slack.createThreadInDirectMessage":r().object({required:{message:r().string(),userIds:r().array(r().string())},optional:{attachedFileIds:r().array(r().string())},exact:!0}),"slack.replyInThread":r().object({required:{message:r().string(),prefixedThreadUri:r().string()},optional:{attachedFileIds:r().array(r().string())},exact:!0}),"slack.updateMessage":r().object({required:{message:r().string(),prefixedMessageUri:r().string()},optional:{},exact:!0}),"slack.addReactionToMessage":r().object({required:{prefixedMessageUri:r().string(),reaction:r().string()},optional:{},exact:!0}),"slack.removeReactionFromMessage":r().object({required:{prefixedMessageUri:r().string(),reaction:r().string()},optional:{},exact:!0}),"slack.getThreadsInChannelSince":r().object({required:{channelName:r().string(),timestamp:r().string()},optional:{},exact:!0}),"slack.queryChannels":r().object({required:{},optional:{botIsMember:r().boolean(),createdEnd:r().string(),createdStart:r().string(),id:r().string(),isGeneral:r().boolean(),isIm:r().boolean(),isMpim:r().boolean(),isOrgShared:r().boolean(),isPrivate:r().boolean(),isShared:r().boolean(),name:r().string()},exact:!0}),"slack.getUser":r().object({required:{userId:r().string()},optional:{},exact:!0}),"slack.findUserByEmail":r().object({required:{email:r().string()},optional:{},exact:!0}),"slack.parseSlackMessageUrlToId":r().object({required:{url:r().string()},optional:{},exact:!0})},k=(r().object({required:{channelId:r().string(),channelName:r().string()},optional:{},exact:!0}),r().union([r().isUndefined(),r().object({required:{},optional:{channelId:r().string(),channelName:r().string()},exact:!0})]),r().union([r().object({required:{allChannels:r().literal(!1),channels:r().array(r().object({required:{channelId:r().string(),channelName:r().string()},optional:{},exact:!0}))},optional:{},exact:!0}),r().object({required:{allChannels:r().literal(!0)},optional:{},exact:!0})]),r().union([r().object({required:{allChannels:r().literal(!1),channels:r().array(r().union([r().isUndefined(),r().object({required:{},optional:{channelId:r().string(),channelName:r().string()},exact:!0})]))},optional:{},exact:!0}),r().object({required:{allChannels:r().literal(!0)},optional:{},exact:!0})]),{dataTypes:"",dataTypesArray:[],persistedStateValidator:m,persistedState:"\nname?: string // The workspace name\nconnectionPointer?: RecordPointer<WorkflowExternalScopedConnectionTable>\n/**\n * This is a list of scopes selected by the user for the current module.\n * This will default to empty/undefined to encourage the user to think\n * about what functionality this module needs.\n */\nscopes?: Array<string>",triggers:f,effects:y,effectsArray:["slack.createThreadInChannel","slack.createThreadInDirectMessage","slack.replyInThread","slack.updateMessage","slack.addReactionToMessage","slack.removeReactionFromMessage","slack.getThreadsInChannelSince","slack.queryChannels","slack.getUser","slack.findUserByEmail","slack.parseSlackMessageUrlToId"],effectsValidators:b}),I=(r().object({required:{assignee_id:r().union([r().isNull(),r().number()]),created_at:r().string(),description:r().string(),id:r().number(),requester_id:r().number(),status:r().lazy((()=>I)),subject:r().string(),submitter_id:r().number(),updated_at:r().string(),url:r().string()},optional:{brand_id:r().nullable(r().number()),collaborator_ids:r().array(r().number()),custom_fields:r().array(r().object({required:{id:r().number(),value:r().unknown()},optional:{}})),due_at:r().nullable(r().string()),email_cc_ids:r().array(r().number()),external_id:r().nullable(r().string()),follower_ids:r().array(r().number()),from_messaging_channel:r().boolean(),group_id:r().nullable(r().number()),has_incidents:r().boolean(),organization_id:r().nullable(r().number()),priority:r().nullable(r().lazy((()=>w))),problem_id:r().nullable(r().number()),satisfaction_rating:r().object({required:{score:r().string()},optional:{comment:r().string(),id:r().number()}}),sharing_agreement_ids:r().array(r().number()),tags:r().array(r().string()),ticket_form_id:r().nullable(r().number()),type:r().nullable(r().lazy((()=>v))),via:r().object({required:{channel:r().string()},optional:{source:r().record(r().string(),r().unknown())}})}}),r().object({required:{author_id:r().number(),body:r().string(),html_body:r().string(),id:r().number(),plain_body:r().string(),public:r().boolean(),type:r().literal("Comment")},optional:{attachments:r().array(r().object({required:{content_type:r().string(),content_url:r().string(),file_name:r().string(),id:r().number(),size:r().number()},optional:{}})),created_at:r().string(),metadata:r().record(r().string(),r().unknown()),via:r().object({required:{channel:r().string()},optional:{source:r().record(r().string(),r().unknown())}})}}),r().literals("closed","hold","new","open","pending","solved")),w=r().literals("high","low","normal","urgent"),v=r().literals("incident","problem","question","task"),T=(r().object({required:{createdAt:r().string(),description:r().string(),id:r().string(),status:r().lazy((()=>I)),subject:r().string(),updatedAt:r().string(),url:r().string()},optional:{priority:r().lazy((()=>w)),tags:r().array(r().string()),type:r().lazy((()=>v))},exact:!0}),r().object({required:{body:r().string(),htmlBody:r().string(),id:r().string(),plainBody:r().string()},optional:{createdAt:r().string()},exact:!0}),{dataTypes:'\ntype ZendeskTicketStatus =\n\t| "new"\n\t| "open"\n\t| "pending"\n\t| "hold"\n\t| "solved"\n\t| "closed"\n\ntype ZendeskTicketPriority = "urgent" | "high" | "normal" | "low"\n\ntype ZendeskTicketType = "problem" | "incident" | "question" | "task"\n\ntype ZendeskTicket = {\n\tid: string // This is a zendesk ticket ID\n\tsubject: string\n\tdescription: string\n\tstatus: ZendeskTicketStatus\n\tpriority?: ZendeskTicketPriority\n\ttype?: ZendeskTicketType\n\turl: string // This is the URL of the ticket\n\ttags?: Array<string>\n\tcreatedAt: string\n\tupdatedAt: string\n}\n\ntype ZendeskComment = {\n\tid: string // This is a zendesk comment ID\n\tbody: string\n\thtmlBody: string\n\tplainBody: string\n\tcreatedAt?: string\n}',dataTypesArray:["ZendeskTicketStatus","ZendeskTicketPriority","ZendeskTicketType","ZendeskTicket","ZendeskComment"],persistedStateValidator:r().object({required:{},optional:{},exact:!0}),persistedState:"",triggers:{"zendesk.ticket":{state:'\nreadonly type: "zendesk.ticket"\nreadonly status?: ZendeskTicketStatus // Filter by ticket status (e.g. "new", "open", "pending", "solved", "closed"). Webhook will trigger if the status matches.\nreadonly priority?: ZendeskTicketPriority // Filter by ticket priority (e.g. "urgent", "high", "normal", "low"). Webhook will trigger if the priority matches.\nreadonly tags?: ReadonlyArray<string> // Filter by ticket tags. Webhook will trigger if any of the tags match.',stateValidator:r().object({required:{type:r().literal("zendesk.ticket")},optional:{externalId:r().string(),priority:r().lazy((()=>w)),status:r().lazy((()=>I)),tags:r().array(r().string()),triggerId:r().string()},exact:!0})}},effects:{"zendesk.getTicket":"getTicket(args: { ticketId: number }): Promise<ZendeskTicket>","zendesk.addTicket":"\naddTicket(args: {\n\t\tsubject: string\n\t\tdescription: string\n\t\tpriority?: ZendeskTicketPriority\n\t\tstatus?: ZendeskTicketStatus\n\t\ttags?: Array<string>\n\t\tassigneeId?: number\n\t}): Promise<ZendeskTicket>","zendesk.addComment":"\naddComment(args: {\n\t\tticketId: number\n\t\tbody: string\n\t\tpublic?: boolean\n\t}): Promise<ZendeskComment>","zendesk.getComments":"getComments(args: { ticketId: number }): Promise<Array<ZendeskComment>>","zendesk.updateTicket":"\nupdateTicket(args: {\n\t\tticketId: number\n\t\tstatus?: ZendeskTicketStatus\n\t\tpriority?: ZendeskTicketPriority\n\t\ttags?: Array<string>\n\t}): Promise<ZendeskTicket>"},effectsArray:["zendesk.getTicket","zendesk.addTicket","zendesk.addComment","zendesk.getComments","zendesk.updateTicket"],effectsValidators:{"zendesk.getTicket":r().object({required:{ticketId:r().number()},optional:{},exact:!0}),"zendesk.addTicket":r().object({required:{description:r().string(),subject:r().string()},optional:{assigneeId:r().number(),priority:r().lazy((()=>w)),status:r().lazy((()=>I)),tags:r().array(r().string())},exact:!0}),"zendesk.addComment":r().object({required:{body:r().string(),ticketId:r().number()},optional:{public:r().boolean()},exact:!0}),"zendesk.getComments":r().object({required:{ticketId:r().number()},optional:{},exact:!0}),"zendesk.updateTicket":r().object({required:{ticketId:r().number()},optional:{priority:r().lazy((()=>w)),status:r().lazy((()=>I)),tags:r().array(r().string())},exact:!0})}}),U=["calendar","codegen","config","files","github","mail","mcpServer","notion","pipedream","slack","zendesk"],x={calendar:i,codegen:a,config:l,files:c,github:n(771111).fM,mail:d,mcpServer:u,notion:g,pipedream:h,slack:k,zendesk:T}},349470:(e,t,n)=>{n.d(t,{QB:()=>s,Wh:()=>l,od:()=>a});n(581454);var r=()=>n(24153);const i=["pageOrCollectionViewBlock","view","collection","discussion","collectionProperty","collectionPropertyOption","pageDiscussions","discussion","integration","trigger","user","agent"],o="file",a=[...i,o,...r().y1];function s(){return[...i.map((e=>`${e}://[\\w\\-\\_\\/]+`)),...r().y1.map((e=>`${e}://[\\w\\/\\-\\.]+[\\w]`)),`${o}:\\/\\/%7B[^}]+%7D`]}function l(e){for(const t of a)if(e===t)return!0;return!1}},365646:(e,t,n)=>{n.d(t,{CK:()=>g,G1:()=>d,Gu:()=>u,MV:()=>c,UO:()=>o,eN:()=>i,gY:()=>p,oA:()=>l});n(16280);var r=()=>n(395797);const i=["anthropic-sonnet-4","anthropic-sonnet-4-thinking","anthropic-opus-4","anthropic-opus-4-thinking","anthropic-opus-4.1","anthropic-opus-4.1-thinking","anthropic-sonnet-alt","anthropic-sonnet-alt-thinking","anthropic-sonnet-3.7","anthropic-sonnet-3.7-thinking","openai-gpt-4.1","openai-gpt-4.1-mini","openai-gpt-5-mini","openai-gpt-5-nano","openai-o3","openai-o4-mini","gemini-pro","gemini-flash","openai-turbo","openai-turbo-thinking","openai-turbo-minimal-thinking","openai-turbo-10","openai-turbo-8"],o={"anthropic-sonnet-4":"anthropic-sonnet-4","anthropic-sonnet-4-thinking":"anthropic-sonnet-4","anthropic-opus-4":"anthropic-opus-4","anthropic-opus-4-thinking":"anthropic-opus-4","anthropic-opus-4.1":"anthropic-opus-4.1","anthropic-opus-4.1-thinking":"anthropic-opus-4.1","anthropic-sonnet-alt":"anthropic-sonnet-alt","anthropic-sonnet-alt-thinking":"anthropic-sonnet-alt","anthropic-sonnet-3.7":"anthropic-sonnet-3.7","anthropic-sonnet-3.7-thinking":"anthropic-sonnet-3.7","openai-gpt-4.1":"openai-gpt-4.1","openai-gpt-4.1-mini":"openai-gpt-4.1-mini","openai-gpt-5-mini":"openai-gpt-5-mini","openai-gpt-5-nano":"openai-gpt-5-nano","openai-o3":"openai-o3","openai-o4-mini":"openai-o4-mini","gemini-pro":"vertex-gemini-2.5-pro","gemini-flash":"vertex-gemini-2.5-flash","openai-turbo":"openai-turbo","openai-turbo-thinking":"openai-turbo","openai-turbo-minimal-thinking":"openai-turbo","openai-turbo-10":"openai-turbo","openai-turbo-8":"openai-turbo"},a={pending:["streaming","confirmation:requested","applied","applied:partial","applied:error"],streaming:["confirmation:requested","applied","applied:partial","applied:error","confirmation:rejected"],"confirmation:requested":["applied","applied:partial","applied:error","confirmation:rejected"],"confirmation:rejected":[],"confirmation:confirmed":[],applied:[],"applied:partial":[],"applied:error":[]},s={pending:[],streaming:["confirmation:rejected"],"confirmation:requested":[],"confirmation:confirmed":[],"confirmation:rejected":[],applied:[],"applied:partial":[],"applied:error":[]};function l(e,t,n){const r=u(e);if(!function(e,t,n){return e===t||!!a[e].includes(t)||!(null==n||!n.isAsyncMode)&&s[e].includes(t)}(r,t,n))throw new Error(`Invalid tool state transition from "${r}" to "${t}"`);const i={...e,state:t};return"confirmation:requested"===t&&(i.requestedConfirmation=!0),i}const c=["create-database","update-database","update-database-data-sources","update-database-views","update-database-triggers","create-pages","update-page","delete-pages"];function d(e){return e}function u(e){return e.state?e.state:e.done?"applied":(0,r().rk)(e)}function p(e,t){return e.toolType===t}function g(e){return"agent-trigger"===e.type}},395797:(e,t,n)=>{function r(e){return"applied"===e.state||"applied:partial"===e.state||"applied:error"===e.state||"confirmation:rejected"===e.state||"confirmation:confirmed"===e.state||!0===e.done}function i(e){return"confirmation:requested"===e.state||"requested"===e.userConfirmation}function o(e){return"confirmation:rejected"===e.state||"rejected"===e.userConfirmation}function a(e){switch(e.userConfirmation){case"requested":return"confirmation:requested";case"confirmed":return"applied";case"rejected":return"confirmation:rejected";default:return e.state??"pending"}}n.d(t,{I6:()=>i,dB:()=>o,nP:()=>r,rk:()=>a})},499919:(e,t,n)=>{n.d(t,{$q:()=>a,AF:()=>s});var r=()=>n(761865);const i="://",o="-";function a(e){if(e.prefix.includes(i))throw new(r().xL)('Prefix {prefix} cannot include a "{separator}"',{prefix:e.prefix,separator:i});const t=`${e.prefix}${i}`;return e.id.startsWith(t)?e.id:`${t}${e.id}`}function s(e){const{prefix:t,id:n,originModule:a}=e,s=`${t}${o}`;if(n.startsWith(s))return n.slice(s.length);const l=`${t}${i}`;if(!n.startsWith(l)){const e=n.split(i)[0],o=n.includes(i)?` Instead it appears to be a ${e} id.`:` It appears to be malformed and without the ${t} prefix.`,s=a?` Ensure that the id comes from the ${a} module.`:"";throw new(r().Yv)("Id {id} is not a {prefix} id.{appearsToBeMessage}{moduleMessage}",{id:n,prefix:t,appearsToBeMessage:o,moduleMessage:s})}return n.slice(l.length)}},563452:(e,t,n)=>{n.d(t,{Hf:()=>g,It:()=>p,OT:()=>u,Zg:()=>m,my:()=>y,pN:()=>b,yC:()=>f});n(16280),n(813451),n(898992),n(354520),n(581454);var r=()=>n(534177),i=()=>n(365646),o=()=>n(761865),a=()=>n(158489),s=()=>n(134025),l=()=>n(696706),c=()=>n(728272),d=()=>n(66757);function u(e){const{transcript:t}=e,{activeIntegrationPointers:n}=p(t);if(0===n.length)return[];const r=(0,a().YO)({transcript:t});return n.map((e=>{const t=r.getModel(e);if(!t)throw new(o().xL)("Module not found: {module}",{module:e.toString()});const n=t.toModuleValue();if(!n)throw new(o().xL)("Module value not found: {module}",{module:e.toString()});return n}))}function p(e){const t=new(c().d),n=new(c().d),r=function(e){return e.findLastIndex((e=>"agent-integration"===e.type))}(e);if(r>-1){const i=e[r];if("agent-integration"!==i.type)throw new Error(`Expected step to be an agent integration step but was ${i.type}`);for(const e of i.activeRecordPointers??[])t.add(e);for(const e of i.inactiveRecordPointers??[])n.add(e)}for(let i=r<0?0:r+1;i<e.length;i++){const r=e[i];if(!h(r)&&!m(r)||!r.result)continue;const{activeIntegrationPointers:o,inactiveIntegrationPointers:a}=r.result;for(const e of o??[])t.add(e),n.delete(e);for(const e of a??[])t.delete(e),n.add(e)}return{activeIntegrationPointers:Array.from(t),inactiveIntegrationPointers:Array.from(n)}}function g(e){return!("string"!=typeof e||!(0,r().Xk)(d().zP,e))}function h(e){return!("agent-tool-result"!==e.type||!(0,i().gY)(e,"toggle-user-integration-tools"))}function m(e){return!("agent-tool-result"!==e.type||!(0,i().gY)(e,"update-user-integrations"))}function f(e){return e}function y(e,t){return t?{...e,permissions:t}:e}function b(e){var t,n,i,o;const{updateIntegrationStep:c,workflowModuleModel:d}=e,u=d.pointer,p=d.toModuleValue(),g=(0,a().Gl)(c.threadRecordMap);g.addModel(d);const f=(0,a().he)(g),y=d.getData();if(!y)throw new Error("Workflow module data is undefined");const b=(0,a().B_)(s().op.set({args:y,path:["data"],pointer:u}));if(h(c))return{...c,threadOperations:[...c.threadOperations??[],b],threadRecordMap:f};m(c)||(0,r().HB)(c);const k=((null===(t=c.result)||void 0===t?void 0:t.createdIntegrationValues)??[]).map((e=>l().L3.isEqual(e.pointer,u)?{...e,moduleValue:p}:e)),I=((null===(n=c.result)||void 0===n?void 0:n.updatedIntegrationValues)??[]).map((e=>l().L3.isEqual(e.pointer,u)?{...e,moduleValue:p}:e));return{...c,result:{activeIntegrationPointers:(null===(i=c.result)||void 0===i?void 0:i.activeIntegrationPointers)??[],createdIntegrationValues:k,inactiveIntegrationPointers:(null===(o=c.result)||void 0===o?void 0:o.inactiveIntegrationPointers)??[],updatedIntegrationValues:I},threadOperations:[...c.threadOperations??[],b],threadRecordMap:f}}},669604:(e,t,n)=>{n.d(t,{IK:()=>i,VR:()=>o});var r=()=>n(638681);function i(...e){return r().object({required:{table:r().literals(...e),id:r().string(),spaceId:r().string()},optional:{}})}function o(...e){return r().object({required:{table:r().literals(...e),id:r().string()},optional:{spaceId:r().string()}})}},687249:(e,t,n)=>{n.d(t,{nm:()=>k,Xh:()=>E,GP:()=>N,$e:()=>A,ne:()=>v,CM:()=>w,w8:()=>q,Q2:()=>I,dw:()=>M,dE:()=>R,TE:()=>O,Mg:()=>C,OR:()=>P,X1:()=>j});n(16280),n(898992),n(354520),n(581454),n(964979),n(814603),n(147566),n(198721);var r=()=>n(498212),i=()=>n(534177),o=()=>n(997769),a=()=>n(651784),s=()=>n(179034),l=()=>n(519831),c=()=>n(197959),d=()=>n(798880),u=()=>n(743246),p=()=>n(978234),g=()=>n(563452),h=()=>n(761865),m=()=>n(499919);var f=()=>n(349470);function y(e){if((0,r().uj)(e))return e;if((0,r().c_)(e))return(0,r().np)(e);throw new(h().Yv)("Invalid UUID: {id}",{id:e})}function b(e,t){let n=e.toString();if("notion.so"===e.hostname){const e=new URL(n);e.hostname="www.notion.so",n=e.toString()}const[r]=(0,a().Jq)({url:n,isMobile:!1,baseUrl:t.baseUrl,publicDomainName:t.publicDomainName,protocol:void 0,currentUrl:void 0});return r}const k={pageOrCollectionViewBlock:{type:"pageOrCollectionViewBlock",parseUri:e=>{if(!e.startsWith("page"))return Error(`Invalid page or collection view block URL, must start with "page": ${e}`);const t=e.split("://")[1].split("/"),n=t[0],r=t[1];return n?{type:"pageOrCollectionViewBlock",id:y(n),blockId:r}:Error(`Invalid page or collection view block URL: ${e}`)},getUri:({id:e,blockId:t,baseUrl:n})=>I({baseUrl:n,pageId:e,blockId:t}),parseUrlToUri:(e,t)=>{try{const{pageOrBlockId:n,blockId:r}=P(e.toString(),t);if(n)return`pageOrCollectionViewBlock://${n}${r?`/${r}`:""}`}catch(n){return new(h().Yv)("Invalid page or collection view block URL: {url}",{url:e},{cause:n})}return new(h().Yv)("Invalid page or collection view block URL: {url}",{url:e})}},collection:{type:"collection",parseUri:e=>{const t=e.split("collection://")[1];return t?{type:"collection",collectionId:y(t)}:new Error(`Invalid collection URL: {{${e}}}`)},getUri:({collectionId:e})=>w(e),parseUrlToUri:(e,t)=>{const n=b("string"==typeof e?new URL(e):e,t);return"collection"!==n.name?new(h().Yv)("Invalid collection URL: {url}",{url:e}):w(n.collectionId)}},collectionProperty:{type:"collectionProperty",parseUri:e=>{const t=e.split("collectionProperty://")[1].split("/"),n=t[0],r=U(t[1]);return n&&r?{type:"collectionProperty",collectionId:y(n),propertyId:r}:Error(`Invalid collection property URL: ${e}`)},getUri:({collectionId:e,propertyId:t})=>v(e,t)},collectionPropertyOption:{type:"collectionPropertyOption",parseUri:e=>{const t=e.split("collectionPropertyOption://")[1].split("/"),n=t[0],r=U(t[1]),i=U(t[2]);return n&&r&&i?{type:"collectionPropertyOption",collectionId:y(n),propertyId:r,optionId:i}:Error(`Invalid collection property option URL: ${e}`)},getUri:({collectionId:e,propertyId:t,optionId:n})=>function(e,t,n){const r=T(t),i=T(n);return`collectionPropertyOption://${e}/${r}/${i}`}(e,t,n)},discussion:{type:"discussion",parseUri:e=>{const t=e.split("discussion://")[1].split("/");if(1===t.length){const n=t[0];return n?{type:"discussion",discussionId:y(n)}:Error(`Invalid discussion URL: ${e}`)}if(2===t.length){const[n,r]=t;return n&&r?{type:"discussion",pageId:y(n),discussionId:y(r)}:Error(`Invalid discussion URL: ${e}`)}if(3===t.length){const[n,r,i]=t;return n&&r&&i?{type:"discussion",pageId:y(n),blockId:y(r),discussionId:y(i)}:Error(`Invalid discussion URL: ${e}`)}return Error(`Invalid discussion URL: ${e}`)},getUri:({discussionId:e,pageId:t,blockId:n})=>function(e){const{discussionId:t,pageId:n,blockId:r}=e;if(n&&r)return`discussion://${n}/${r}/${t}`;if(n)return`discussion://${n}/${t}`;return`discussion://${t}`}({discussionId:e,pageId:t,blockId:n}),getUrl:({discussionId:e,pageId:t,blockId:r,baseUrl:i})=>(0,n(921940).A)({discussionId:e,pageId:t,scrollToBlockId:r!==t?r:void 0,baseUrl:i,pageVisitSource:n(584262).y8.AIChat})},pageDiscussions:{type:"pageDiscussions",parseUri:e=>{const t=e.split("pageDiscussions://")[1];return t?{type:"pageDiscussions",pageId:y(t)}:Error(`Invalid page discussions URL: ${e}`)},getUri:({pageId:e})=>function(e){return`pageDiscussions://${e}`}(e)},integration:{type:"integration",parseUri:e=>{const t=e.split("integration://")[1].split("/");if(3===t.length){const[n,r,i]=t;if(!(n&&r&&(0,g().Hf)(r)&&i))throw new(h().Yv)("Invalid integration URL: {{{uri}}}",{uri:e});return{type:"integration",moduleType:r,spaceId:y(n),moduleRecordId:y(i)}}if(4===t.length){const[n,r,i,o]=t;if(!(n&&r&&i&&(0,g().Hf)(i)&&o))throw new(h().Yv)("Invalid integration URL: {{{uri}}}",{uri:e});return{type:"integration",workflowId:y(r),moduleId:o&&"undefined"!==o?y(o):void 0,moduleType:i,spaceId:y(n)}}throw new(h().Yv)("Invalid integration URL: {{{uri}}}",{uri:e})},getUri:function(e){if("workflowId"in e){const{workflowId:t,moduleId:n,moduleType:r,spaceId:i}=e;return`integration://${i}/${t}/${r}/${n}`}{const{moduleType:t,spaceId:n,moduleRecordId:r}=e;return`integration://${n}/${t}/${r}`}}},view:{type:"view",parseUri:e=>{const t=e.split("view://")[1].split("/")[0];return t?{type:"view",collectionViewId:t}:Error(`Invalid view URL: ${e}`)},getUri:({collectionViewId:e})=>x(e),parseUrlToUri:(e,t)=>{const n=b("string"==typeof e?new URL(e):e,t);return"page"===n.name&&n.collectionViewId?x(n.collectionViewId):new(h().Yv)("Invalid view URL: {url}",{url:e})}},trigger:{type:"trigger",parseUri:e=>{const t=e.split("trigger://")[1].split("/"),n=t[0],r=t[1],i=t[2];return n&&r&&i?{type:"trigger",workflowId:y(r),spaceId:y(n),triggerId:i}:Error(`Invalid trigger URL: ${e}`)},getUri:function(e){const{workflowId:t,spaceId:n,triggerId:r}=e;return`trigger://${n}/${t}/${r}`}},agent:{type:"agent",parseUri:e=>{const t=e.split("agent://")[1].split("/"),n=t[0],r=t[1];return n&&r?{type:"agent",spaceId:y(n),workflowId:y(r)}:Error(`Invalid agent URL: ${e}`)},getUri:({workflowId:e,spaceId:t})=>function(e){const{workflowId:t,spaceId:n}=e;return`agent://${n}/${t}`}({workflowId:e,spaceId:t})},user:{type:"user",parseUri:e=>{try{return{type:"user",userId:function(e,{isMocked:t=!1}={}){const n=e;if((0,r().uj)(n)&&!t)return n;try{const t=(0,m().AF)({prefix:"notion_user",id:e});if((0,r().uj)(t))return t}catch(o){}const i=(0,m().AF)({prefix:"user",id:e});if((0,r().uj)(i))return i;if(t)return e;throw new(h().Yv)('{userIdString} is not a valid user ID. While the ID is correctly prefixed with "user://", the rest of the ID is NOT a valid UUID.',{userIdString:e})}(e)}}catch(t){if(t instanceof Error)return t;throw t}},getUri:R},file:{type:"file",parseUri:e=>{const t=e.split("file://")[1];if(!t)return Error(`Invalid file URL: ${e}`);const{source:n,permissionRecord:r}=JSON.parse(decodeURIComponent(t));return{type:"file",source:n,permissionRecord:r}},getUri:q},...n(24153).A2};function I(e){const{baseUrl:t,pageId:n,blockId:i}=e;return`${t}/${(0,r().Xw)(n)}${i?`#${(0,r().Xw)(i)}`:""}`}function w(e){return`collection://${e}`}function v(e,t){return`collectionProperty://${e}/${T(t)}`}function T(e){return btoa(e).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}function U(e){return atob(e.replace(/-/g,"+").replace(/_/g,"/"))}function x(e){return`view://${e}`}function R(e){const{userId:t}=e;return`user://${t}`}function q(e){const{source:t,permissionRecord:n}=e;return`file://${encodeURIComponent(JSON.stringify({source:t,permissionRecord:n}))}`}function S(e){const t=function(e){return e.startsWith("{{")&&e.endsWith("}}")?e.slice(2,-2):e}(e),n=t.split("://")[0];if(!(0,f().Wh)(n))throw new(h().Yv)("Invalid agent URL: {{{processedUri}}}",{processedUri:t});const r=k[n].parseUri(t);if(r instanceof Error)throw r;return r}function C(e,t){const n=e.split("://")[0];if((0,f().Wh)(n))return S(e);let r,i;r=e.startsWith("//")?`https:${e}`:e.startsWith("/")?`${t.baseUrl}${e}`:e.includes("://")?e:`https://${e}`;try{i=new URL(r)}catch(a){throw new(h().Yv)("Invalid agent URL - Failed to parse as URL: {{{urlWithProtocol}}}",{urlWithProtocol:r})}for(const s of f().od){var o;const e=k[s],n=null===(o=e.parseUrlToUri)||void 0===o?void 0:o.call(e,i,t);if("string"==typeof n){if(n.startsWith("https://")){const t=e.parseUri(n);if(t instanceof Error)throw t;return t}return S(n)}}return{type:"webpage",url:r}}function j(e,t){try{return C(e,t)}catch(n){return}}function P(e,t){let n;try{n=b(new URL(e),t)}catch(r){throw new(h().Yv)("Invalid agent URL - Failed to parse as URL: {urlStr}",{urlStr:e})}if("page"!==n.name||!n.blockId)throw new(h().Yv)("Invalid Notion page or app URL: {urlStr}",{urlStr:e});return{pageOrBlockId:n.blockId,blockId:n.scrollToBlockId}}function A(e){const t=S(e);if("collection"!==t.type)throw new(h().Yv)("Invalid data source URL: {{{url}}}",{url:e});return t.collectionId}function $(){return`(${[...(0,f().QB)(),'https?://[^\\s)\\]"}\\\\|]+'].join("|")})`}function E(){return new RegExp($(),"g")}function M(e){var t;const{type:n}=e;switch(n){case"database":case"page":case"pageOrCollectionViewBlock":return{table:s().ev,id:e.id};case"agent":case"trigger":return{table:u().C0,id:e.workflowId,spaceId:e.spaceId};case"collection":case"collectionProperty":case"collectionPropertyOption":return{table:l().Vl,id:e.collectionId};case"integration":if("workflowId"in e)return{table:u().C0,id:e.workflowId,spaceId:e.spaceId};if("moduleRecordId"in e)return{table:p().yM,id:e.moduleRecordId,spaceId:e.spaceId};(0,i().HB)(e);break;case"view":return{table:s().ev,id:e.collectionViewId};case"user":return{table:d().oo,id:e.userId};case"slackUser":case"slackChannel":case"slackMessage":case"webpage":case"universal-object":return;case"file":return"attachmentStep"in e&&"block"===(null===(t=e.attachmentStep.permissionRecord)||void 0===t?void 0:t.table)?e.attachmentStep.permissionRecord:void 0;case"discussion":return{id:e.discussionId,table:c().$Y};case"pageDiscussions":return{id:e.pageId,table:s().ev};default:(0,i().HB)(n)}}function D(e,t){if("slackChannel"===e.type||"slackMessage"===e.type||"slackUser"===e.type)return k[e.type].getUri(e)}function O(e,t){const n=o().I6(e,"url");let r,i=n.length;for(;i--;){r=n[i];const o=j(r.href,t),a=o?D(o):void 0;"string"==typeof a&&(e=e.slice(0,r.start)+a+e.slice(r.end))}return e}const _=f().od.join("|"),L=new RegExp(`((?:${_})://[\\w\\/\\-\\.]+[\\w])`,"gi");function N(e){if(!e.includes("://"))return[];return Array.from(e.matchAll(L)).map((e=>({href:e[0],value:e[0],start:e.index,end:e.index+e[0].length})))}},761865:(e,t,n)=>{n.d(t,{Yv:()=>i,xL:()=>o});n(16280),n(944114),n(581454),n(898992),n(354520),n(672577),n(430670);Error;Error;function r(e,t){return t?e.replace(/\{(\w+)\}/g,((n,r)=>{if(!(r in t))throw new Error(`Missing template variable '${r}' in template: ${e}`);const i=t[r];return i instanceof Error||"object"==typeof i&&null!==i&&"message"in i&&"string"==typeof i.message?i.message:String(i)})):e}class i extends Error{constructor(e,t,n){super(r(e,t),{cause:null==n?void 0:n.cause}),this.template=void 0,this.logContext=void 0,this.extra=void 0,this.name="AgentError",this.template=e,this.logContext=null==n?void 0:n.additionalLogContext,this.extra=null==n?void 0:n.extra,Error.captureStackTrace&&Error.captureStackTrace(this,i)}getErrorForLogging(){const e=this.logContext?`${this.logContext} ${this.template}`:this.template,t=new(n(416845).Um)(e);if(this.stack){const e=this.stack.split("\n"),n=[];for(let t=e.length-1;t>=0;t--){const r=e[t];if(r.match(/^\s+at\s/))n.unshift(r);else if(n.length>0)break}n.length>0?t.stack=[this.template,...n].join("\n"):t.stack=this.template}return this.extra&&(t.data=this.extra),t}sentryExtra(){return{name:this.name,category:"error",level:"error",extra:this.extra}}}Error;class o extends i{constructor(e,t,n){super(e,t,n),this.name="AgentSystemError",Object.setPrototypeOf(this,o.prototype)}}},771111:(e,t,n)=>{n.d(t,{Hv:()=>s,fM:()=>u,jP:()=>l,sq:()=>a,z8:()=>c});var r=()=>n(638681);const i=r().object({required:{description:r().union([r().isNull(),r().string()]),id:r().number(),name:r().string(),parentTeam:r().union([r().isNull(),r().lazy((()=>i))]),slug:r().string(),url:r().string()},optional:{},exact:!0}),o=r().object({required:{},optional:{connectionPointer:(0,n(669604).IK)("workflow_external_scoped_connection"),lastAuthenticatedAtMs:r().number(),scopes:r().array(r().string())},exact:!0}),a=r().object({required:{owner:r().string(),pullNumber:r().number(),repo:r().string()},optional:{},exact:!0}),s=r().object({required:{username:r().string()},optional:{},exact:!0}),l=r().object({required:{owner:r().string(),query:r().union([r().object({required:{cursor:r().string()},optional:{},exact:!0}),r().object({required:{direction:r().literals("asc","desc"),page:r().number(),perPage:r().number(),prState:r().literals("all","closed","open"),sort:r().literals("created","long-running","popularity","updated")},optional:{},exact:!0})]),repo:r().string()},optional:{},exact:!0}),c=r().object({required:{organization:r().string(),query:r().union([r().object({required:{cursor:r().string()},optional:{},exact:!0}),r().object({required:{direction:r().literals("asc","desc"),page:r().number(),perPage:r().number(),repoType:r().literals("all","forks","member","private","public","sources"),sort:r().literals("created","full_name","pushed","updated")},optional:{},exact:!0})])},optional:{},exact:!0}),d=r().object({required:{urls:r().array(r().string())},optional:{},exact:!0}),u={dataTypes:"",dataTypesArray:[],persistedStateValidator:o,persistedState:"\n/**\n * A connection pointer is used for any modules that need to store external\n * authentication state.\n */\nconnectionPointer?: RecordPointer<WorkflowExternalScopedConnectionTable>\n/**\n * This represents the last time the user authenticated for this module.\n * This is used to help determine if the connection has expired from when\n * the user authenticated and us checking if the connection is still active\n * through `hasActiveOAuthConnection`.\n */\nlastAuthenticatedAtMs?: number\n/**\n * This is a list of scopes selected by the user for the current module.\n * This will default to empty/undefined to encourage the user to think\n * about what functionality this module needs.\n */\nscopes?: Array<string>",triggers:{},effects:{"github.getPullRequest":"\n(args: {\n\t\towner: string\n\t\trepo: string\n\t\tpullNumber: number\n\t}) => Promise<GithubPullRequest>","github.getUser":"(args: { username: string }) => Promise<GithubUser>","github.listPullRequests":"\n(args: {\n\t\towner: string\n\t\trepo: string\n\t\tquery: ListPullRequestsQuery\n\t}) => Promise<{\n\t\tcursor: string | undefined\n\t\tpullRequests: Array<GithubPullRequest>\n\t}>","github.listOrganizationRepositories":"\n(args: {\n\t\torganization: string\n\t\tquery: ListRepositoriesQuery\n\t}) => Promise<{\n\t\tcursor: string | undefined\n\t\trepositories: Array<GithubRepository>\n\t}>","github.parseGithubUrlToParts":"\n(args: {\n\t\turls: Array<string>\n\t}) => Array<AllGithubUrls | undefined>"},effectsArray:["github.getPullRequest","github.getUser","github.listPullRequests","github.listOrganizationRepositories","github.parseGithubUrlToParts"],effectsValidators:{"github.getPullRequest":a,"github.getUser":s,"github.listPullRequests":l,"github.listOrganizationRepositories":c,"github.parseGithubUrlToParts":d}}}}]);